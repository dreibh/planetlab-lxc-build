#
# PlanetLab RPM generation
#
# Mark Huang <mlhuang@cs.princeton.edu>
# Copyright (C) 2003-2006 The Trustees of Princeton University
#
# $Id: Rules.mk,v 1.37 2007/09/10 22:24:20 mef Exp $
#

# Base rpmbuild in the current directory
export HOME := $(shell pwd)
export CVSROOT CVS_RSH

#
# Create spec file
#

SPECFILE := SPECS/$(notdir $(SPEC))

$(SPECFILE):
	mkdir -p SPECS
	echo "%define pldistro $(PLDISTRO)" > $@
ifeq ($(TAG),HEAD)
        # Define date for untagged builds
	echo "%define date $(shell date +%Y.%m.%d)" >> $@
else
        # Define cvstag for tagged builds
	echo "%define cvstag $(TAG)" >> $@
endif
	$(if $(CVSROOT),\
	  cvs -d $(if $($(package)-CVSROOT),$($(package)-CVSROOT),$(CVSROOT)) checkout -r $(TAG) -p $(MODULE)/$(SPEC) >> $@; \
	)

	$(if $(SVNPATH),\
	  svn cat $(if $($(package)-SVNPATAH),$($(package)-SVNPATH),$(SVNPATH))/$(MODULE)/$(TAG)/$(SPEC) >> $@; \
	)

#
# Parse spec file into Makefile fragment
#

MK := tmp/$(package).mk

parseSpec: CFLAGS := -g -Wall -D_GNU_SOURCE

parseSpec: LDFLAGS := -lrpm -lrpmbuild

$(MK): $(SPECFILE) parseSpec .rpmmacros
	mkdir -p tmp
	./parseSpec $(RPMFLAGS) $(SPECFILE) > $@

# Defines SOURCES, SRPM, RPMS
include $(MK)

#
# Generate tarball(s)
#

# Get rid of any extensions
stripext = \
$(patsubst %.tar.bz2,%, \
$(patsubst %.tar.gz,%, \
$(patsubst %.tgz,%, \
$(patsubst %.zip,%, \
$(patsubst %.tar,%,$(1))))))

SOURCEDIRS := $(call stripext,$(SOURCES))

# Thierry - Jan 29 2007
# Allow different modules to have  different CVSROOT
# and/or to be extracted from their SVNPATH
#
# is there a single module ? to mimick cvs export -d behaviour
MULTI_MODULE := $(word 2,$(MODULE))
ifeq "$(MULTI_MODULE)" ""
# single module: do as before
SOURCES/$(package):
	mkdir -p SOURCES
	$(if $(CVSROOT),\
	  cd SOURCES && cvs -d $(if $($(package)-CVSROOT),$($(package)-CVSROOT),$(CVSROOT)) export -r $(TAG) -d $(package) $(MODULE);\
	)
	$(if $(SVNPATH),\
	  cd SOURCES && svn export $(if $($(package)-SVNPATH),$($(package)-SVNPATH),$(SVNPATH))/$(MODULE)/$(TAG) $(package);\
	)
else
# multiple modules : iterate 
SOURCES/$(package):
	mkdir -p SOURCES/$(package) && cd SOURCES/$(package) && (\
	$(foreach module,$(MODULE),\
	  $(if $(CVSROOT), \
		cvs -d $(if $($(module)-CVSROOT),$($(module)-CVSROOT),$(CVSROOT)) export -r $(TAG)  $(module);\
	   )
	  $(if $(SVNPATH), \
		svn export $(if $($(module)-SVNPATH),$($(module)-SVNPATH),$(SVNPATH))/$(module)/$(TAG) $(module);\
	   )
	))
endif

# Make a hard-linked copy of the exported directory for each Source
# defined in the spec file. However, our convention is that there
# should be only one Source file and one CVS module per RPM. It's okay
# if the CVS module consists of multiple directories, as long as the
# spec file knows what's going on.
$(SOURCEDIRS): SOURCES/$(package)
	cp -rl $< $@

.SECONDARY: SOURCES/$(package) $(SOURCEDIRS)

# Generate tarballs
SOURCES/%.tar.bz2: SOURCES/%
	tar cpjf $@ -C SOURCES $*

SOURCES/%.tar.gz: SOURCES/%
	tar cpzf $@ -C SOURCES $*

SOURCES/%.tgz: SOURCES/%
	tar cpzf $@ -C SOURCES $*

SOURCES/%.zip: SOURCES/%
	cd SOURCES && zip -r ../$@ $*

SOURCES/%.tar: SOURCES/%
	tar cpf $@ -C SOURCES $*

#
# Build
#

all: $(RPMS) $(SRPM)

# Build RPMS
$(RPMS): $(SPECFILE) $(SOURCES)
	mkdir -p BUILD RPMS
	$(RPMBUILD) $(RPMFLAGS) -bb $<

# Make the rest of the RPMS depend on the first one since building one
# builds them all.
ifneq ($(words $(RPMS)),1)
$(wordlist 2,$(words $(RPMS)),$(RPMS)): $(firstword $(RPMS))
endif

# Build SRPM
$(SRPM): $(SPECFILE) $(SOURCES)
	mkdir -p SRPMS
	$(RPMBUILD) $(RPMFLAGS) -bs $<

# Base rpmbuild in the current directory
.rpmmacros:
	echo "%_topdir $(HOME)" > $@
	echo "%_tmppath $(HOME)/tmp" >> $@

# Remove files generated by this package
clean:
	rm -rf \
	$(RPMS) $(SRPM) \
	$(patsubst SOURCES/%,BUILD/%,$(SOURCEDIRS)) \
	$(SOURCES) $(SOURCEDIRS) SOURCES/$(package) \
	$(MK) $(SPECFILE)

.PHONY: all clean

#################### convenience, for debugging only
# make +foo : prints the value of $(foo)
# make ++foo : idem but verbose, i.e. foo=$(foo)
++%: varname=$(subst +,,$@)
++%:
	@echo $(varname)=$($(varname))
+%: varname=$(subst +,,$@)
+%:
	@echo $($(varname))
